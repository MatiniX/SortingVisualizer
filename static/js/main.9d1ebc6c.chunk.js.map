{"version":3,"sources":["components/infoTabs/imgs/Merge-sort-example-300px.gif","components/infoTabs/imgs/Sorting_quicksort_anim.gif","components/infoTabs/imgs/Bubble-sort-example-300px.gif","components/infoTabs/imgs/Insertion-sort-example-300px.gif","components/infoTabs/imgs/Selection-Sort-Animation.gif","sortingAlgorithms/sortingAlgorithms.js","components/infoTabs/MergeSortInfo.js","components/infoTabs/QuickSortInfo.js","components/infoTabs/BubbleSortInfo.js","components/infoTabs/InsertionSortInfo.js","components/infoTabs/SelectionSortInfo.js","components/infoTabs/ShellSortInfo.js","components/NavBar.js","components/infoTabs/InfoTab.js","components/SortingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","array","DOMBars","sleepMS","finishedCallback","a","length","auxiliaryArray","slice","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","Math","floor","Promise","all","doMergeSort","k","i","j","style","backgroundColor","sleep","height","quickSort","partition","pi","pivot","temp","ms","resolve","setTimeout","getMergeSortAnimations","getQuickSortAnimations","getBubbleSortAnimations","animations","push","bubbleSort","getInsertionSortAnimations","insertionSort","getSelectionSortAnimations","minIdx","selcetionSort","getShellSortAnimations","gap","shellSort","MergeSortInfo","props","className","onClick","close","src","image","alt","href","target","rel","QuickSortInfo","margin","BubbleSortInfo","id","InsertionSortInfo","marginLeft","top","SelectionSoerInfo","scale","ShellSortInfo","NavBar","useState","currAlgorithm","setAlgorithm","isModalOpen","setModalOpen","algorithms","value","label","selecionStyling","container","provided","state","alignSelf","minWidth","methods","resetArray","disabled","isSorting","options","onChange","event","defaultValue","styles","type","min","max","arrSize","setArrSize","placeholder","sortSpeed","Number","isInteger","parseInt","console","log","setSortSpeed","mergeSort","selectionSort","error","isOpen","closeTimeoutMS","html","getInfoTabHTML","InfoTab","opacity","marginTop","randomNumFromInerval","round","random","SortingVisualizer","sessionStorage","getItem","setItem","JSON","stringify","parse","infoModalShow","setInfoModalShow","SORT_SPEED_MS","size","ARRAY_SIZE","useEffect","arr","setArr","resetArrayHook","useArray","setIsSorting","finishCallback","toggleButtons","enabled","genButton","document","getElementById","sortButton","arrayBars","getElementsByClassName","barIndex","newHeight","color","barOneIdx","barTwoIdx","barOneStyle","barTwoStyle","barStyle","idx","barOne","barTwo","map","index","key","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9d1ebc6c.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/Merge-sort-example-300px.a29c0dd0.gif\";","module.exports = __webpack_public_path__ + \"static/media/Sorting_quicksort_anim.d4e5d0a7.gif\";","module.exports = __webpack_public_path__ + \"static/media/Bubble-sort-example-300px.d4c88b8c.gif\";","module.exports = __webpack_public_path__ + \"static/media/Insertion-sort-example-300px.6e67d1c7.gif\";","module.exports = __webpack_public_path__ + \"static/media/Selection-Sort-Animation.f20b8898.gif\";","\r\n//#region Merge Sort\r\n\r\nasync function getMergeSortAnimations(array, DOMBars, sleepMS, finishedCallback) {\r\n    if(array.length <= 1) return array;\r\n    const auxiliaryArray = array.slice();\r\n    await mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, DOMBars, sleepMS);\r\n    finishedCallback();\r\n}\r\n\r\nasync function mergeSortHelper(mainArray, startIdx, endIdx, auxiliaryArray, DOMBars, sleepMS) {\r\n    if(startIdx === endIdx) return;\r\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n    await Promise.all(\r\n        [mergeSortHelper(auxiliaryArray, startIdx , middleIdx, mainArray, DOMBars, sleepMS)],\r\n        [mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, DOMBars, sleepMS)]);\r\n    await doMergeSort(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, DOMBars, sleepMS);\r\n}\r\n\r\nasync function doMergeSort(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, DOMBars, sleepMS) {\r\n    let k = startIdx;\r\n    let i = startIdx;\r\n    let j = middleIdx + 1;\r\n\r\n    while (i <= middleIdx && j <= endIdx) {\r\n        //Zmena farby porovnávaných prvkov\r\n        DOMBars[i].style.backgroundColor = \"#dd0510\";\r\n        DOMBars[j].style.backgroundColor = \"#dd0510\";\r\n        //Sleep aby sme vizualizovali zmenu\r\n        await sleep(sleepMS);\r\n        //Zmena farby porovnávaných prvkov späť\r\n        DOMBars[i].style.backgroundColor = \"#05b2dd\";\r\n        DOMBars[j].style.backgroundColor = \"#05b2dd\";\r\n        if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n            //Prepíšeme hodnotu na indexu k v originálnej array na hodnotu na pozícii i v pomocnej array\r\n            DOMBars[k].style.height = `${auxiliaryArray[i] * 0.75}px`;\r\n            mainArray[k++] = auxiliaryArray[i++];\r\n        }\r\n        else {\r\n            //Prepíšeme hodnotu na indexu k v originálnej array na hodnotu na pozícii j v pomocnej array\r\n            DOMBars[k].style.height = `${auxiliaryArray[j] * 0.75}px`;\r\n            mainArray[k++] = auxiliaryArray[j++];\r\n        }\r\n    }\r\n    while (i <= middleIdx) {\r\n        //Kopírovanie hodnôt z prvej polovice array ak ostali\r\n        DOMBars[i].style.backgroundColor = \"#dd0510\";\r\n        await sleep(sleepMS);\r\n        //Hodnoty ktoré v mergeSorte porovnávame; pushneme znova aby sme zmenili ich farbu späť\r\n        DOMBars[i].style.backgroundColor = \"#05b2dd\";\r\n        //Prepíšeme hodnotu na pozícii k v originálne array na hodnotu na pozícii i v pomocnej array\r\n        DOMBars[k].style.height = `${auxiliaryArray[i] * 0.75}px`;\r\n        mainArray[k++] = auxiliaryArray[i++];\r\n    }\r\n    while (j <= endIdx) {\r\n        //Kopírovanie hodnôt z druhej polovice array ak ostali\r\n        DOMBars[j].style.backgroundColor = \"#dd0510\";\r\n        await sleep(sleepMS);\r\n        //Hodnoty ktoré v mergeSorte porovnávame; pushneme znova aby sme zmenili ich farbu späť\r\n        DOMBars[j].style.backgroundColor = \"#05b2dd\";\r\n        //Prepíšeme hodnotu na pozícii k v originálne array na hodnotu na pozícii j v pomocnej array\r\n        DOMBars[k].style.height = `${auxiliaryArray[j] * 0.75}px`;\r\n        mainArray[k++] = auxiliaryArray[j++];\r\n    }\r\n}\r\n\r\n//#endregion\r\n\r\n//#region Quick Sort\r\nasync function getQuickSortAnimations(array, DOMBars, sleepMS, finishedCallback) {\r\n    if(array.length <= 1) return array;\r\n    await quickSort(array, 0, array.length - 1, DOMBars, sleepMS);\r\n    finishedCallback();\r\n}\r\n\r\nasync function quickSort(array, startIdx, endIdx, DOMBars, sleepMS) {\r\n    if(startIdx < endIdx) {\r\n        let pi = await partition(array, startIdx, endIdx, DOMBars, sleepMS);\r\n\r\n        await Promise.all(\r\n            [quickSort(array, startIdx, pi - 1, DOMBars, sleepMS)],\r\n            [quickSort(array, pi + 1, endIdx, DOMBars, sleepMS)]);\r\n    }\r\n}\r\n\r\nasync function partition(array, startIdx, endIdx, DOMBars, sleepMS) {\r\n    //Nastavíme farbu pivota\r\n    DOMBars[endIdx].style.backgroundColor = 'green';\r\n\r\n    let pivot = array[endIdx];\r\n    let i = startIdx - 1;\r\n\r\n    for (let j = startIdx; j < endIdx; j++) {\r\n        //Zmeníme farbu práve porovnávaného prvku a počkáme\r\n        DOMBars[j].style.backgroundColor = \"#dd0510\";\r\n        await sleep(sleepMS);\r\n        if (array[j] < pivot) {\r\n            i++;\r\n            //Zmeníme farbu prvku ktorý sa chystáme vymeniť a počkáme\r\n            DOMBars[i].style.backgroundColor = \"#dd0510\";\r\n            await sleep(sleepMS);\r\n            //Nastavíme výšku prvku na indexe i na výšku prvku na indexe j a zmeníme farbu\r\n            DOMBars[i].style.height = `${array[j] * 0.75}px`;\r\n            DOMBars[i].style.backgroundColor = \"#05b2dd\";\r\n            const temp = array[i];\r\n            //Nastavíme výšku prvku na indexe j na výšku prvku na predošlom indexe i, zmeníme farbu a počkáme\r\n            DOMBars[j].style.height = `${temp * 0.75}px`\r\n            DOMBars[j].style.backgroundColor = \"#05b2dd\";\r\n            await sleep(sleepMS);\r\n            array[i] = array[j];\r\n            array[j] = temp;           \r\n        }\r\n        //Zmeníme farbu práve porovnávaného prvku späť\r\n        DOMBars[j].style.backgroundColor = \"#05b2dd\";\r\n    }\r\n    //Zmeníme farbu pivot na červenú aby sme naznačili posledný swap\r\n    DOMBars[endIdx].backgroundColor = \"#dd0510\";\r\n    //Nastavíme výšku prvku na indexe i+1 na výšku pivota\r\n    DOMBars[i + 1].style.height = `${array[endIdx] * 0.75}px`;\r\n    DOMBars[i + 1].style.backgroundColor = \"#05b2dd\";\r\n    await sleep(sleepMS);\r\n\r\n    const temp = array[i + 1];\r\n    //Nastavíme výšku pivota na výšku na indexe i+1\r\n    DOMBars[endIdx].style.height = `${temp * 0.75}px`;\r\n    DOMBars[endIdx].style.backgroundColor = \"#05b2dd\";\r\n    array[i + 1] = array[endIdx];\r\n    array[endIdx] = temp;\r\n    return i + 1;\r\n}\r\n//#endregion\r\n\r\n//#region Bubble Sort\r\nfunction getBubbleSortAnimations(array) {\r\n    const animations = [];\r\n    bubbleSort(array, animations);\r\n    return animations;\r\n}\r\n\r\nfunction bubbleSort(array, animations) {\r\n    for (let i = 0; i < array.length - 1; i++) {\r\n        for (let j = 0; j < array.length - i - 1; j++) {\r\n            //Pushneme indexy porovnávanych prvkov aby sme zmenili ich farbu\r\n            animations.push([j,j + 1]);\r\n            if (array[j] > array[j + 1]) {\r\n                const temp = array[j];\r\n                array[j] = array[j + 1];\r\n                array[j + 1] = temp;\r\n            }\r\n            //Pushneme animácie pre výmenu prvkov\r\n            animations.push([j, array[j]]);\r\n            animations.push([j + 1, array[j + 1]]);\r\n            //Pushneme indexy porovnávanych prvkov aby sme zmenili farbu späť\r\n            animations.push([j, j + 1]);\r\n        }\r\n    }\r\n}\r\n//#endregion\r\n\r\n//#region Insertion Sort\r\nfunction getInsertionSortAnimations(array) {\r\n    const animations = [];\r\n    insertionSort(array, animations);\r\n    return animations;\r\n}\r\n\r\nfunction insertionSort(array, animations) {\r\n    let j;\r\n    //Animácie pre zmenu farby 1. prvku\r\n    animations.push([]);\r\n    for (let i = 1; i < array.length; i++) {\r\n        j = i;\r\n        //Pushneme animáciu na zmenu farby porovnávaneho prvku\r\n        animations.push([j, array[j], \"#dd0510\"]);\r\n        while (j > 0 && array[j - 1] > array[j]) {\r\n            //Pushneme animácie pre swap prvkov a zmenu ich farieb\r\n            animations.push([j, array[j - 1], \"green\"]);\r\n            animations.push([j - 1, array[j], \"#dd0510\"]);\r\n            const temp = array[j];\r\n            array[j] = array[j - 1];\r\n            array[j - 1] = temp;\r\n            j--;\r\n        }\r\n        //Pushneme animáciu pre zmenu farby prvku ktorý sme práve zoradili\r\n        animations.push([j, array[j], \"green\"]);\r\n    }\r\n    //Animácia pre reset farieb\r\n    animations.push([]);\r\n}\r\n//#endregion\r\n\r\n//#region Selection Sort\r\nfunction getSelectionSortAnimations(array) {\r\n    const animations = [];\r\n    selcetionSort(array, animations);\r\n    return animations;\r\n}\r\n\r\nfunction selcetionSort(array, animations) {\r\n    for(let i = 0; i < array.length; i++) {\r\n        let minIdx = i;\r\n        //Pushneme animáciu pre zmenu farby prvku s počiatočným minIdx\r\n        animations.push([i, array[i], \"#dd0510\"]);\r\n        //Pushneme animáciu pre zmenu farby späť prvku s počiatočným minIdx\r\n        animations.push([i, array[i], \"#05b2dd\"]);\r\n        for (let j = i + 1; j < array.length; j++) {\r\n            //Pushneme animáciu pre zmenu farby práve porovnávaneho prvku\r\n            animations.push([j, array[j], \"#dd0510\"]);\r\n            //Pushneme animáciu pre zmenu farby späť práve porovnávaneho prvku\r\n            animations.push([j, array[j], \"#05b2dd\"]);\r\n            if (array[j] < array[minIdx] ) {\r\n                //Pushneme anímáciu pre zmenu farby predošlého najmenšieho prvku\r\n                animations.push([minIdx, array[minIdx], \"#05b2dd\"]);\r\n                minIdx = j;\r\n                //Pushneme animáciu pre označenie nového najmenšieho prvku\r\n                animations.push([minIdx, array[minIdx], \"brown\"]);\r\n            }\r\n        }\r\n        const temp = array[i];\r\n        array[i] = array[minIdx];\r\n        array[minIdx] = temp;\r\n        //Pushneme animáciu pre swap a zmenu farby už zoradeného prvku\r\n        animations.push([i, array[i], \"green\"]);\r\n        if(i !== minIdx) {\r\n            //Pushneme animáciu pre zmenu farby ešte nezoradeného prvku\r\n            animations.push([minIdx, array[minIdx], \"#05b2dd\"]);\r\n        }\r\n    }\r\n    //Animácia pre reset farieb\r\n    animations.push([]);\r\n}\r\n//#endregion\r\n\r\n//#region Shell Sort\r\nfunction getShellSortAnimations(array) {\r\n    const animations = [];\r\n    shellSort(array, animations);\r\n    return animations;\r\n}\r\n\r\nfunction shellSort(array, animations) {\r\n    for (let gap = Math.floor(array.length / 2) ; gap > 0; gap = Math.floor(gap / 2)) {\r\n        for (let i = gap; i < array.length; i++) {\r\n            //Pushneme animáciu pre označenie temp \r\n            //animations.push([i, array[i], \"#dd0510\"]);\r\n            let temp = array[i];\r\n            let j;\r\n            for (j = i; j >= gap && array[j - gap] > temp; j -= gap) {\r\n                //Pushneme animáciu pre zmenu farby\r\n                animations.push([j, j - gap, \"compare\"]);\r\n                //Animácia pre zmenu farby späť\r\n                animations.push([j, j - gap, \"compare\"]);\r\n                //Animácie pre zmenu hodnôt\r\n                animations.push([j, array[j - gap], \"#05b2dd\"]);\r\n                array[j] = array[j - gap]\r\n            }\r\n            //Pushnema animáciu pre zmenu farby a veľkosti\r\n            animations.push([j, temp, \"#dd0510\"]);\r\n            //Pushnema animáciu pre zmenu farby späť\r\n            animations.push([j, temp, \"#05b2dd\"]);\r\n            array[j] = temp;\r\n        }\r\n    }\r\n}\r\n//#endregion\r\n\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nexport default {getMergeSortAnimations, getQuickSortAnimations,getBubbleSortAnimations, getInsertionSortAnimations, getSelectionSortAnimations, getShellSortAnimations};","import React from \"react\"\r\nimport image from \"./imgs/Merge-sort-example-300px.gif\"\r\n\r\n\r\nexport default function MergeSortInfo(props) {\r\n    return (\r\n        <div className=\"info-tab\">\r\n            <button className=\"close-button\" onClick={props.close}>&#10006;</button>\r\n            <h2 className=\"info-tab-title\">Merge Sort</h2>\r\n            <div className=\"about-section\">\r\n                <p>\r\n                    Merge sort je efektívny všeobecne-účelový triediaci algoritmus. Patrí do kategórie \"Rozdeliť a dobiť\" algoritmov.\r\n                     To znamená, že väčšie problémy rozdelí na menšie ľahšie riešiteľné. Bol vynájdený roku 1945 Johnom von Neumannom.\r\n                </p>\r\n                <h3>Algoritmus:</h3>\r\n                <div>\r\n                    Konceptuálne merge sort funguje následovne:\r\n                    <div className=\"list-img\">\r\n                        <ol>\r\n                            <li>\r\n                                <p>\r\n                                    Rozdelovať nezoradený list až kým neostane n \"pod-listov\", ktoré obsahujú každý 1 prvok (list s jedným prvkom je považovaný za zoradený) \r\n                                </p>\r\n                            </li>\r\n                            <li>\r\n                                <p>\r\n                                    Opakovane zlučovať tieto \"pod-listy\" a výtvárať nové zoradené \"pod-listy\" až kým neostane len jeden. To bude náš zoradený list.\r\n                                </p>\r\n                            </li>\r\n                        </ol>\r\n                        <img src={image} alt=\"mal bi tu byť animovaný obrázok ale není :(\"></img>\r\n                    </div>\r\n                    <br />\r\n                    <br />\r\n                    <p>\r\n                        <p className=\"pop-up\">Časová komplexnosť<div>Časová komplexnosť algoritmu popisuje čas, ktorý algoritmus potrebuje k svojej exekúcii.\r\n                            Obyčajne je odhadnutá počitaním počtom základnych operácii, ktoré algoritmus urobí za predpokladu že každá táto operácia zaberie konštantný čas.</div>&nbsp;</p>\r\n                         Merge sortu je O(n log n) pre priemerný aj najhorší prípad. Neoperuje však na mieste. To znamená, že sú potrebné pomocné kópie \r\n                        hodnôt.\r\n                    </p>\r\n                    <p>\r\n                        Implementovať sa dá dvomi spôsobmi. Zhora-dole a Zdola-hore. Pri implementácií zhora-dole algoritmus rekurzívne delí list na polovice až kým \r\n                        neostanú listy s jedným prvkom a potom tieto listy postupne zlúči a zoradí. Pri implementácií zdola-hore sú jednotlivé prvky v už brané ako listy\r\n                        s jedným prvkom a iteratívne zlučované a zoradované.\r\n                    </p>\r\n                    <div className=\"code-section\">\r\n                        <code>\r\n                            <pre>\r\n                                {`function merge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray) {\r\n    var k = startIdx;\r\n    var i = startIdx;\r\n    var j = middleIdx + 1;\r\n\r\n    while (i <= middleIdx && j <= endIdx) {\r\n        if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n            mainArray[k] = auxiliaryArray[i];\r\n            k++;\r\n            i++;\r\n        }\r\n        else {\r\n            mainArray[k] = auxiliaryArray[j];\r\n            k++;\r\n            j++;\r\n        }\r\n    }\r\n    while (i <= middleIdx) {\r\n        mainArray[k] = auxiliaryArray[i];\r\n        k++;\r\n        i++;\r\n    }\r\n    while (j <= endIdx) {\r\n        mainArray[k] = auxiliaryArray[j];\r\n        k++;\r\n        j++;\r\n    }\r\n}\r\n\r\nfunction mergeSort(mainArray, startIdx, endIdx, auxiliaryArray) {\r\n    if(startIdx === endIdx) return;\r\n    var middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n\r\n    mergeSort(auxiliaryArray, startIdx , middleIdx, mainArray);\r\n    mergeSort(auxiliaryArray, middleIdx + 1, endIdx, mainArray);\r\n\r\n    merge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray);\r\n}`}\r\n                            </pre>\r\n                        </code>\r\n                    </div>\r\n                    <div className=\"explanation-section\">\r\n                        Takýmto spôsobom je implementovaný merge sort na tejto stránke. Ide o implementáciu zhora-dole. Kde <p className=\"code-highlight\">mainArray</p> je list, ktorý chceme zoradiť  \r\n                        a <p className=\"code-highlight\">auxiliaryArray</p> je kópia tohto listu. Aktuálne zoraďovanie potom prebieha vo \r\n                        funkcii <p className=\"code-highlight\">merge()</p>. Potom funkcia <p className=\"code-highlight\">mergeSort()</p> rekurzívne volá samu seba na obidvoch\r\n                        poloviciach listu s tým rozdielom, že tento raz vymeníme poradie parametrov a namiesto <p className=\"code-highlight\">mainArray</p> dáme <p className=\"code-highlight\">auxiliaryArray</p>.\r\n                        Takto postupne zoradíme <p className=\"code-highlight\">auxiliaryArray</p>, až kým\r\n                        neostanú dve zoradené polovice listu tie potom v zlúčime do finálneho listu ako možno vidieť vo vizualizácii. Treba si uvedomiť že celý čas pracujeme\r\n                        na <p className=\"code-highlight\">auxiliaryArray</p>, ktorú postupne rozdeľujeme a následovne zlučujeme a až v poslednej iterácii rekurzie\r\n                        zlúčime hodnoty do <p className=\"code-highlight\">mainArray</p> čo bude naša finálna zoradená verzia listu. Vo vizualizácii môžete vidieť \r\n                        rekurziu prebiehať súčasne.\r\n                    </div>\r\n                    <div className=\"references-box\">\r\n                        <b>Zdroje:</b>\r\n                        <br/>\r\n                        <a href=\"https://en.wikipedia.org/wiki/Merge_sort\" target=\"_blank\" rel=\"noopener noreferrer\">Wikipedia</a>\r\n                        <br/>\r\n                        <a href=\"https://www.youtube.com/watch?v=JSceec-wEyw\" target=\"_blank\" rel=\"noopener noreferrer\">Krátke video, ktoré znázorňuje koncept algoritmu</a>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","import React from \"react\"\r\n\r\nimport image from \"./imgs/Sorting_quicksort_anim.gif\";\r\n\r\nexport default function QuickSortInfo(props) {\r\n    return(\r\n        <div className=\"info-tab\">\r\n            <button className=\"close-button\" onClick={props.close}>&#10006;</button>\r\n            <h2 className=\"info-tab-title\">Quick Sort</h2>\r\n            <div className=\"about-section\">\r\n                <p>\r\n                    Quick sort je efektívny triediaci algoritmus, ktorý patrí do kategórie \"Rozdeliť a dobiť\" algoritmov. Vynájdený bol roku 1959 britským\r\n                    počítačovým vedcom menom Tony Hoare a dodnes je to bežne používnaý algoritmus pre triedenie. Správne implementovaný môže býť\r\n                    2- až 3- krát rýchlejší ako jeho hlavný konkurenti merge sort a heap sort. \r\n                </p>\r\n                <h3>Algoritmus:</h3>\r\n                <div>\r\n                    Konceptuálne quick sort funguje následovne:\r\n                    <div className=\"list-img\">\r\n                        <ol>\r\n                            <li>\r\n                                <p>\r\n                                    Vybrať z listu prvok zvaný <i>pivot</i>.\r\n                                </p>\r\n                            </li>\r\n                            <li>\r\n                                <p>\r\n                                    <i>Delenie:</i> Zoradiť prvky v liste tak aby prvky s hodnotou menšiou ako <i>pivot</i> boli v liste pred <i>pivotom</i> (naľavo od <i>pivota</i>)\r\n                                    a aby prvky väčšie ako <i>pivot</i> boli v liste za ním (napravo od <i>pivota</i>).\r\n                                    <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                                    Po tomto je <i>pivot</i> vo svojej finálnej pozícii.\r\n                                </p>\r\n                            </li>\r\n                            <li>\r\n                                <p>\r\n                                    Rekurzívne aplikovať tieto kroky na pod-list naľavo od <i>pivota</i> a rovnako na pod-list napravo.\r\n                                </p>\r\n                            </li>\r\n                        </ol>\r\n                        <img src={image} style={{margin: \"2em 0 0 2em\"}} alt=\"mal by tu byť animovaný obrázok ale není :(\"/>\r\n                    </div>\r\n                    <br/>\r\n                    <br/>\r\n                    <p>\r\n                    <p className=\"pop-up\">Časová komplexnosť<div>Časová komplexnosť algoritmu popisuje čas, ktorý algoritmus potrebuje k svojej exekúcii.\r\n                            Obyčajne je odhadnutá počitaním počtom základnych operácii, ktoré algoritmus urobí za predpokladu že každá táto operácia zaberie konštantný čas.</div>&nbsp;</p> quick sortu je O(n log n) pre priemerný prípad ale pre najhorší prípad je to O(n<sup>2</sup>). Najhorší prípad je\r\n                        však pomerne vzácny. Operuje na mieste, potrebuje len malé monožstvo dotatočnej pamäte aby zoradil prvky.\r\n                    </p>\r\n                    <p>\r\n                        Implementovať sa dá mnohými spôsobmi. Implementácie sa potom líšia na základe toho aku schému pre delenie prvkov používajú a akým \r\n                        spôsobom je vybraný <i>pivot</i> v liste.\r\n                    </p>\r\n                    <p>\r\n                        Schémy pre delenie sú 2:<br/>\r\n                        <b>Lomutova schéma.</b> Táto schéma najprv zvolí <i>pivota</i> (typicky posledný prvok v liste). Potom algoritmus zachováva index <i>i</i> zatiaľ\r\n                         čo skenuje list za pomoci ďalšieho indexu <i>j</i> tak aby hodnoty od začiatku listu až po <i>i - 1</i> (vrátane) boli\r\n                        menšie ako <i>pivot</i> a hodnoty od <i>i</i> až po koniec listu boli väčšie ako <i>pivot</i>. Táto schéma je kompaktnejšia a ľahšie\r\n                        pochopiteľná aj keď menej efektívna ako pôvodná Hoareova schéma.<br/>\r\n                        <b>Hoareova schemá.</b> Originálna schéma popísaná tvorcom quick sortu. Táto schéma využíva 2 indexy na začiatku a na konci listu, ktoré\r\n                        sa postupne približujú pokým nenarazia na inverziu: pár prvkov z ktorých je jeden väčší alebo alebo rovný <i>pivotovy</i> a druhý\r\n                        menší alebo rovný <i>pivotovy</i> a sú v zlom poradí relatívne k sebe (menší prvok je napravo od <i>pivota</i> väčší naľavo). \r\n                        Potom sú prvky vymenené. Keď sa indexy stretnú algoritmus sa zastaví a vráti finálny index <i>pivota.</i> Táto schéma je efektívnejšia\r\n                        pretože urobí v priemere až 3-krát menej porovnaní ako Lomutova.\r\n                    </p>\r\n                    <p>\r\n                        Ďaľším problémom implementácie je potom výber <i>pivota</i>. Keďže tento krok rozhoduje práve o tom koľko porovnaní algoritmus urobí.\r\n                        Ideálne chceme vybrať prvok, ktorý bude vo zoradenej verzii listu práve v jeho strede. Poradie v akom prvky po zoradení skončia však nevieme\r\n                        preto výber <i>pivota</i> môžme previesť niekoľkými spôsobmi. Najľahšie je vybrať za <i>pivota</i> prvý, prostredný, posledný alebo náhodný\r\n                        prvok. Odporúča sa však vybrať \"medián troch\", pri tomto výbere <i>pivota</i> sa vybere prostredná hodnota z prvého, prostredného a posledného\r\n                        prvku v liste.\r\n                    </p>\r\n                \r\n                    <div className=\"code-section\">\r\n                    <pre>\r\n                        {`function quickSort(array, startIdx, endIdx) {\r\n    if(startIdx < endIdx) {\r\n        var pivot = partition(array, startIdx, endIdx);\r\n\r\n        quickSort(array, startIdx, pi - 1);\r\n        quickSort(array, pi + 1, endIdx);\r\n    }\r\n}\r\n\r\nfunction partition(array, startIdx, endIdx) {\r\n    \r\n    var pivot = array[endIdx];\r\n    var i = startIdx - 1;\r\n\r\n    for (var j = startIdx; j < endIdx; j++) {\r\n        if (array[j] < pivot) {\r\n            i++;\r\n            var temp = array[i];\r\n            array[i] = array[j];\r\n            array[j] = temp;           \r\n        }\r\n    }\r\n    var temp = array[i + 1];\r\n    array[i + 1] = array[endIdx];\r\n    array[endIdx] = temp;\r\n    return i + 1;\r\n}`}\r\n                    </pre>\r\n                    </div>\r\n                    <div className=\"explanation-section\">\r\n                        Takýmto spôsobom je implementovaný quick sort na tejto stránke. Použitá je Lomutova schéma a za <i>pivot</i> je výbraný posledný prvok v liste. \r\n                        Samotné triedenie a výber pivota prebieha vo funkcii <p className=\"code-highlight\">partition()</p>, ktorá potom navráti index pivota a potom\r\n                        funkcia <p className=\"code-highlight\">quickSort()</p> rekurzívne volá samu seba naľavej a napravej strane listu od pivota. Toto je\r\n                        vo vizualizácii zobrazené objavením ďalších pivotných bodov (zelené hodnoty) a zoraďovaním prvkov pred nimi.  \r\n                    </div>\r\n                    <div className=\"references-box\">\r\n                        <b>Zdroje:</b>\r\n                        <br/>\r\n                        <a href=\"https://en.wikipedia.org/wiki/Quicksort\" target=\"_blank\" rel=\"noopener noreferrer\">Wikipedia</a>\r\n                        <br/>\r\n                        <a href=\"https://www.youtube.com/watch?v=PgBzjlCcFvc\" target=\"_blank\" rel=\"noopener noreferrer\">Krátke video, ktoré znázorňuje koncept algoritmu</a>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}","import React from \"react\";\r\n\r\nimport image from \"./imgs/Bubble-sort-example-300px.gif\"\r\n\r\nexport default function BubbleSortInfo(props) {\r\n    \r\n    return(\r\n        <div className=\"info-tab\">\r\n            <button className=\"close-button\" onClick={props.close}>&#10006;</button>\r\n            <h2 className=\"info-tab-title\">Bubble Sort</h2>\r\n            <div className=\"about-section\">\r\n                <p>\r\n                   Bubble sort je jednoduchý avšak veľmi neefektívny tiediaci algoritmus. Kvôli svojej jednoduchosti je bubble sort často používaný na\r\n                   predstavenie konceptu triediaceho algoritmu. Aj keď niektorý odborníci doporučujú aby sa už nevyučoval.\r\n                </p>\r\n                <h3>Algoritmus:</h3>\r\n                <div>\r\n                    Koncept bubble sortu je veľmi jednoduchý. Porovnávať susedné prvky v liste a vymeniť ich v prípade ak sú v zlom poradí. Tento postup\r\n                    opakovať až kým list nebude zoradený.\r\n                    \r\n                    <p>\r\n                    <p className=\"pop-up\">Časová komplexnosť<div>Časová komplexnosť algoritmu popisuje čas, ktorý algoritmus potrebuje k svojej exekúcii.\r\n                            Obyčajne je odhadnutá počitaním počtom základnych operácii, ktoré algoritmus urobí za predpokladu že každá táto operácia zaberie konštantný čas.</div>&nbsp;</p> bubble sortu je O(n<sup>2</sup>) pre priemerný aj najhorší prípad. Kvôli tomuto je bubble sort tak neefektívny. Dokonca\r\n                        aj iné triediace algoritmy, ktoré majú rovnakú časovú komplexnosť ako napríklad insertion sort, sú obecne rýcheljšie ako bubble sort.\r\n                        Operuje na mieste. \r\n                    </p>\r\n                    <div className=\"code-section\">\r\n                        <pre>\r\n                            {`function bubbleSort(array) {\r\n    for (var i = 0; i < array.length - 1; i++) {\r\n        for (var j = 0; j < array.length - i - 1; j++) {\r\n            if (array[j] > array[j + 1]) {\r\n                const temp = array[j];\r\n                array[j] = array[j + 1];\r\n                array[j + 1] = temp;\r\n            }\r\n        }\r\n    }\r\n}`}\r\n                        </pre>\r\n                    </div>\r\n                    <img id=\"bubble-sort-img\" src={image} alt=\"mal by tu byť animovaný obrázok ale není :(\"></img>\r\n                    <div className=\"explanation-section\">\r\n                        Implementovať bubble sort je veľmi jednoduché ako môžte vidieť. Aj keď je bubble sort veľmi neefektívny má využitie v počítačovej grafike vďaka svojej\r\n                        schopnosti detekovať malé chyby(ako napríklad nesprávne poradie dvoch prvkov) v takmer zoradených listoch. \r\n                    </div>\r\n                    <div className=\"references-box\">\r\n                        <b>Zdroje:</b>\r\n                        <br/>\r\n                        <a href=\"https://en.wikipedia.org/wiki/Bubble_sort\" target=\"_blank\" rel=\"noopener noreferrer\">Wikipedia</a>\r\n                        <br/>\r\n                        <a href=\"https://www.youtube.com/watch?v=nmhjrI-aW5o\" target=\"_blank\" rel=\"noopener noreferrer\">Krátke video, ktoré znázorňuje koncept algoritmu</a>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}","import React from \"react\";\r\n\r\nimport image from \"./imgs/Insertion-sort-example-300px.gif\";\r\n\r\nexport default function InsertionSortInfo(props) {\r\n    return(\r\n        <div className=\"info-tab\">\r\n            <button className=\"close-button\" onClick={props.close}>&#10006;</button>\r\n            <h2 className=\"info-tab-title\">Insertion Sort</h2>\r\n            <div className=\"about-section\">\r\n                <p>\r\n                   Insertion sort je jednoduchý triediaci algoritmus, ktorý postupne buduje finálny zoradený list prvok po prvku. Je neefektívny pre veľké listy oproti\r\n                   pokoročilejším algoritmom ako merge sort alebo quick sort. Napriek tomu má svoje výhody.\r\n                </p>\r\n                <h3>Algoritmus:</h3>\r\n                <div>\r\n                    Podobne ako keď zoraďujeme karty v rukách. Najprv zoradíme prvé dve a potom ďalšie umiestnime zodpovedajúco medzi ostatné. \r\n                    Insertion sort iteruje cez list a postupne z každou iteráciou vyberie prvok a správne ho umiestni na jeho pozíciu. Tento postup opakuje až kým\r\n                    v liste neostávajú žiadne nezoradené prvky. \r\n                    <p>\r\n                    <p className=\"pop-up\">Časová komplexnosť<div>Časová komplexnosť algoritmu popisuje čas, ktorý algoritmus potrebuje k svojej exekúcii.\r\n                            Obyčajne je odhadnutá počitaním počtom základnych operácii, ktoré algoritmus urobí za predpokladu že každá táto operácia zaberie konštantný čas.</div>&nbsp;</p> insertion sortu je O(n<sup>2</sup>) pre priemerný a najhorší prípad. Operuje na mieste. Jednou z jeho výhod je, že patrí medzi <i>online</i> algoritmy.\r\n                        To znamená, že dokáže spracovať dáta súčasne ako ich prijíma. Aj keď je neefektívny pre veľké listy, tak pre malé listy\r\n                       patrí k najrýchlejším, dokonca je rýchlejší ako quick sort.\r\n                    </p>\r\n                    <div className=\"code-section\">\r\n                        <pre>\r\n                            {`function insertionSort(array) {\r\n    var j;\r\n    for (var i = 1; i < array.length; i++) {\r\n        j = i;\r\n        while (j > 0 && array[j - 1] > array[j]) {\r\n            var temp = array[j];\r\n            array[j] = array[j - 1];\r\n            array[j - 1] = temp;\r\n            j--;\r\n        }\r\n    }\r\n}`}\r\n                        </pre>\r\n                        <img src={image} style={{marginLeft: \"94em\", top: \"16.3em\"}} alt=\"mal by tu byť animovaný obrázok ale není :(\"></img>\r\n                    </div>\r\n                    <div className=\"explanation-section\">\r\n                        Takto jednoducho možno implementovať insertion sort. Insertion sort má vlastnoť, že po <i>n</i> iteráciach je prvých <i>n</i> + 1 prvkov v\r\n                        liste zoradených (+ 1 preto lebo po prvej iterácii zoradíme hneď dva prvky). Vo vizualizácii sú zelenou zvýraznené zoradené prvky.\r\n                    </div>\r\n                    <div className=\"references-box\">\r\n                        <b>Zdroje:</b>\r\n                        <br/>\r\n                        <a href=\"https://en.wikipedia.org/wiki/Insertion_sort\" target=\"_blank\" rel=\"noopener noreferrer\">Wikipedia</a>\r\n                        <br/>\r\n                        <a href=\"https://www.youtube.com/watch?v=OGzPmgsI-pQ\" target=\"_blank\" rel=\"noopener noreferrer\">Krátke video, ktoré znázorňuje koncept algoritmu</a>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}","import React from \"react\";\r\n\r\nimport image from \"./imgs/Selection-Sort-Animation.gif\"\r\n\r\nexport default function SelectionSoerInfo(props) {\r\n    return(\r\n        <div className=\"info-tab\">\r\n            <button className=\"close-button\" onClick={props.close}>&#10006;</button>\r\n            <h2 className=\"info-tab-title\">Selection Sort</h2>\r\n            <div className=\"about-section\">\r\n                <p>\r\n                   Selection sort je jednoduchý triediaci algoritmus. Je neefektívny pre veľké listy. Je podobný insertion sortu ale obecne menej efektívny ako insertion sort.\r\n                </p>\r\n                <h3>Algoritmus:</h3>\r\n                <div>\r\n                    Selection sort rozdelí list na zoradenú a nezoradenú polovicu. Potom iteruje cez nezoradenú polovicu z ktorej vybere najmenší prvok a vymení ho \r\n                    s prvým prvkom v nezoradenej polovici a potom posunie hranice obidvoch polovíc. Zpočiatku je zoradená polovica prázdna a nezoradená polovica je celý list.\r\n                    <p>\r\n                    <p className=\"pop-up\">Časová komplexnosť<div>Časová komplexnosť algoritmu popisuje čas, ktorý algoritmus potrebuje k svojej exekúcii.\r\n                            Obyčajne je odhadnutá počitaním počtom základnych operácii, ktoré algoritmus urobí za predpokladu že každá táto operácia zaberie konštantný čas.</div>&nbsp;</p> je O(n<sup>2</sup>) pre priemerný a najhorší prípad. Operuje na mieste.\r\n                    </p>\r\n                    <div className=\"code-section\">\r\n                        <pre>\r\n                            {`function selcetionSort(array) {\r\n    for(var i = 0; i < array.length; i++) {\r\n        var minIdx = i;\r\n        for (let j = i + 1; j < array.length; j++) {\r\n            if (array[j] < array[minIdx] ) {]);\r\n                minIdx = j;\r\n            }\r\n        }\r\n        var temp = array[i];\r\n        array[i] = array[minIdx];\r\n        array[minIdx] = temp;\r\n        }\r\n    }\r\n}`}\r\n                        </pre>\r\n                        <img src={image} style={{scale: \"0.56\", marginLeft: \"107.5em\", top: \"10em\"}} alt=\"mal by tu byť animovaný obrázok ale není :(\"></img>\r\n                    </div>\r\n                    <div className=\"explanation-section\">\r\n                        Týmto spôsobom je implementovaný selection sort na tejto stránke. Selection sort sa od iných triediacich algoritmov líši hlavne tým,\r\n                        že vždy urobí najmenej <i>n</i> - 1 výmien. Zoradená polovica je vo vizualizácii znázornená zelenou a najmenší prvok je zvýraznený \r\n                        údajne <i>hnedou</i> (možno som len farboslepý). Červenou je zvýraznený prvok, cez ktorý pravé iterujem. \r\n                    </div>\r\n                    <div className=\"references-box\">\r\n                        <b>Zdroje:</b>\r\n                        <br/>\r\n                        <a href=\"https://en.wikipedia.org/wiki/Selection_sort\" target=\"_blank\" rel=\"noopener noreferrer\">Wikipedia</a>\r\n                        <br/>\r\n                        <a href=\"https://www.youtube.com/watch?v=xWBP4lzkoyM\" target=\"_blank\" rel=\"noopener noreferrer\">Krátke video, ktoré znázorňuje koncept algoritmu</a>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}","import React from \"react\"\r\n\r\nexport default function ShellSortInfo(props) {\r\n    return(\r\n        <div className=\"info-tab\">\r\n            <button className=\"close-button\" onClick={props.close}>&#10006;</button>\r\n            <h2 className=\"info-tab-title\">Shell Sort</h2>\r\n            <div className=\"about-section\">\r\n                <p>\r\n                   Na shell sort môžme pozerať buď ako na verziu insertion sortu (väčšinou) alebo bubble sortu. Pracuje tak, že porovnáva prvky, ktoré sú od seba vzidalené \r\n                   nejakou <i>medzerou</i>, ktorú potom postupne zmenšuje. Shell sort je <i>adaptívny</i> algoritmus. To znamená, že je efektívnejší ak je vstup už čiastočne zoradený.\r\n                    Prvá verzia bola publikovaná  Donaldom Shellom v roku 1959.\r\n                </p>\r\n                <h3>Algoritmus:</h3>\r\n                <div>\r\n                    Princípom algoritmu je porovnávať prvky, ktoré sú od seba vzdialené nejakou <i>medzerou</i> a vymeniť ich ak sú v nesprávnom poradí narozdiel\r\n                     od susedných ako v insertion sorte. Túto medzeru potom postupne zmenšujeme až kým nie je veľkosť <i>medzery</i> 1 vtedy algoritmus pracuje\r\n                     rovanko ako insertion sort, po tejto iterácii je list zoradený. <i>Medzeru</i> potom vypočítame pre každú iteráciu. \r\n                    <p>\r\n                       Shell sort operuje na mieste. Časová komplexsnoť tohto algoritmu potom závisí od toho akým spôsobom vypočítavame <i>medzeru</i>, ktorá je medzi\r\n                       prvkami. Všeobecne ale platí, že pre najhorší prípad je <p className=\"pop-up\">časová komplexnosť<div>Časová komplexnosť algoritmu popisuje čas, ktorý algoritmus potrebuje k svojej exekúcii.\r\n                            Obyčajne je odhadnutá počitaním počtom základnych operácii, ktoré algoritmus urobí za predpokladu že každá táto operácia zaberie konštantný čas.</div>&nbsp;</p> O(n<sup>2</sup>) a pre priemerný je to O(n<sup>3/2</sup>) alebo \r\n                       O(n<sup>5/4</sup>). Určenie časovej komplexnosti pre niektoré sekvencie <i>medzier</i> ostáva ako otvorený problém.\r\n                    </p>\r\n                    <div className=\"code-section\">\r\n                        <pre>\r\n                            {`function shellSort(array) {\r\n    for (var gap = array.length / 2 ; gap > 0; gap = gap / 2) {\r\n        for (var i = gap; i < array.length; i++) {\r\n            var temp = array[i];\r\n            var j;\r\n            for (j = i; j >= gap && array[j - gap] > temp; j -= gap) {\r\n                array[j] = array[j - gap]\r\n            }\r\n            array[j] = temp;\r\n        }\r\n    }\r\n}`}\r\n                        </pre>\r\n                    </div>\r\n                    <div className=\"explanation-section\">\r\n                        V tejto implementácii začneme s medzerou, ktorá je <i>dĺžka listu/2</i> a s každou iteráciou ju zmenšime o polovicu (<i>medzera/2</i>). Potom vždy\r\n                        začneme porovnávať prvky od prvku, ktorý ma index <i>medzery</i> s prvkami, ktoré sú vždy o veľkosť našej <i>medzery</i> pred ním v liste. Ak sú v zlom\r\n                        poradí tak ich vymeníme. Takto postupujeme až kým veľkosť <i>medzery</i> nie je 1. Vo vizualizácii sú potom červenou zvýraznené prvky, ktoré porovnávame a\r\n                        vymieňame.\r\n                    </div>\r\n                    <div className=\"references-box\">\r\n                        <b>Zdroje:</b>\r\n                        <br/>\r\n                        <a href=\"https://en.wikipedia.org/wiki/Shellsort\" target=\"_blank\" rel=\"noopener noreferrer\">Wikipedia</a>\r\n                        <br/>\r\n                        <a href=\"https://www.youtube.com/watch?v=SHcPqUe2GZM\" target=\"_blank\" rel=\"noopener noreferrer\">Krátke video, ktoré znázorňuje koncept algoritmu</a>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}","import React, { useState } from \"react\"\r\nimport Select from \"react-select\"\r\nimport ReactModal from \"react-modal\"\r\n\r\nimport MergeSortInfo from \"./infoTabs/MergeSortInfo\"\r\nimport QuickSortInfo from \"./infoTabs/QuickSortInfo\"\r\nimport BubbleSortInfo from \"./infoTabs/BubbleSortInfo\"\r\nimport InsertionSortInfo from \"./infoTabs/InsertionSortInfo\"\r\nimport SelectioSortInfo from \"./infoTabs/SelectionSortInfo\"\r\nimport ShellSortInfo from \"./infoTabs/ShellSortInfo\"\r\n\r\nfunction NavBar(props) {\r\n\r\nconst [currAlgorithm, setAlgorithm] = useState(\"mergeSort\");\r\nconst [isModalOpen, setModalOpen] = useState(false);\r\n\r\nconst algorithms = [\r\n    { value: 'mergeSort', label: 'Merge Sort' },\r\n    { value: 'quickSort', label: 'Quick Sort' },\r\n    { value: 'bubbleSort', label: 'Bubble Sort' },\r\n    { value: 'insertionSort', label: 'Insertion Sort' },\r\n    { value: 'selectionSort', label: 'Selection Sort' },\r\n    { value: 'shellSort', label: 'Shell Sort' }\r\n  ]\r\n  const selecionStyling = {\r\n      container: (provided, state) =>({\r\n          ...provided,\r\n          marginLeft: '2em',\r\n          alignSelf: 'center',\r\n          minWidth: '10em'\r\n      })\r\n  }\r\n  \r\n\r\nfunction changeAlgorithm(event) {\r\n    setAlgorithm(event.value);\r\n}\r\nfunction setArrSize(event) {\r\n    props.methods.setArrSize(event.target.value);\r\n}\r\nfunction setSortingSpeed(event) {\r\n    if (Number.isInteger(parseInt(event.target.value))) {\r\n        console.log(event.target.value);\r\n        props.methods.setSortSpeed(parseInt(event.target.value));\r\n    }\r\n}\r\n\r\nfunction sort() {\r\n    switch (currAlgorithm) {\r\n        case \"mergeSort\":\r\n            props.methods.mergeSort()\r\n            break;\r\n        case \"quickSort\":\r\n            props.methods.quickSort()\r\n            break;\r\n        case \"bubbleSort\":\r\n            props.methods.bubbleSort()\r\n            break;\r\n        case \"insertionSort\":\r\n            props.methods.insertionSort()\r\n            break;\r\n        case \"selectionSort\":\r\n            props.methods.selectionSort()\r\n            break;\r\n        case \"shellSort\":\r\n            props.methods.shellSort()\r\n            break;\r\n        default:\r\n            console.error(\"nemalo by sa nikdy stať\")\r\n            break;\r\n    }\r\n}\r\nfunction getInfoTabHTML() {\r\n    let html;\r\n\r\n    switch (currAlgorithm) {\r\n        case \"mergeSort\":\r\n            html  = <MergeSortInfo close={() => setModalOpen(false)}/>\r\n            break;\r\n        case \"quickSort\":\r\n            html = <QuickSortInfo close={() => setModalOpen(false)}/>\r\n            break;\r\n        case \"bubbleSort\":\r\n            html = <BubbleSortInfo close={() => setModalOpen(false)}/>\r\n            break;\r\n        case \"insertionSort\":\r\n            html = <InsertionSortInfo close={() => setModalOpen(false)}/>\r\n            break;\r\n        case \"selectionSort\":\r\n            html = <SelectioSortInfo close={() => setModalOpen(false)}/>\r\n            break;\r\n        case \"shellSort\":\r\n            html = <ShellSortInfo close={() => setModalOpen(false)}/>\r\n            break;\r\n        default:\r\n            console.error(\"nemalo by sa nikdy stať\")\r\n            break;\r\n    }\r\n    return html;\r\n}\r\n\r\n\r\n    return(\r\n        <div>\r\n            <nav className=\"navbar-container\">              \r\n                    <div className=\"generate-button\">\r\n                        <button id=\"genButton\" onClick={() => props.methods.resetArray()} disabled={props.isSorting}>\r\n                            <span>Generovať</span>\r\n                        </button>\r\n                    </div>\r\n                    <Select options={algorithms} onChange={changeAlgorithm} defaultValue={algorithms[0]} styles={selecionStyling}/>\r\n                    <div className=\"ask-button\" onClick={() => setModalOpen(true)}>\r\n                        <button >\r\n                            <span>?</span>\r\n                        </button>\r\n                    </div>\r\n                    <div className=\"slider-container\">\r\n                        <input type=\"range\" min=\"10\" max=\"350\" className=\"slider\" value={props.arrSize} onChange={setArrSize}/>\r\n                        <p className=\"slider-text\">Počet prvkov: {props.arrSize}</p>\r\n                    </div>\r\n                    <input type=\"text\" className=\"sorting-speed-area\" placeholder={props.sortSpeed} onChange={setSortingSpeed}/>\r\n                    <div className=\"sort-button\">\r\n                        <button id=\"sortButton\" onClick={sort} disabled={props.isSorting}>\r\n                            <span>Zoradiť</span>\r\n                        </button>\r\n                    </div>\r\n            </nav>\r\n            <ReactModal isOpen={isModalOpen} closeTimeoutMS={200}>\r\n                {getInfoTabHTML()}\r\n            </ReactModal>\r\n        </div>\r\n    )\r\n\r\n}\r\nexport default NavBar","import React from \"react\"\r\n\r\nexport default function InfoTab(props) {\r\n    return (\r\n        <div className=\"info-tab\">\r\n            <button className=\"close-button\" onClick={props.close}>&#10006;</button>\r\n            <h2 className=\"info-tab-title\">O projekte</h2>\r\n            <div className=\"about-section\">\r\n                <p>\r\n                   Tento projekt vznikol z kopy voľného času a s úmyslom naučiť sa pracovať s React.js frameworkom a zlepšiť sa v JavaScripte. Ide o interaktívnu SPA \r\n                   aplikáciu, ktorej základom je už spomenutý React.js framework. Inšpiráciou pre aplikáciu bolo toto <a href=\"https://www.youtube.com/watch?v=pFXYym4Wbkc\" target=\"_blank\" rel=\"noopener noreferrer\">video.</a>\r\n                </p>\r\n                <p>\r\n                    Témou sú algoritmy. Konkrétne triediace algoritmy. Cieľom je predstaviť užívateľovi niektoré najznámejšie tieto algoritmy a vizuálne znázorniť ako pracujú.\r\n                    Ku každému algoritmu potom existuje aj infokarta, ktorá: vysvsetľuje ako algoritmus pracuje, aké sú niektoré jeho vlastnosti, kde sa využíva, nejaké\r\n                    zaujímavé informácie o danom algoritme, spolu s ukážkou ako sa dá daný algoritmus implementovať. Užívateľ má možnosť meniť niektoré hodnoty a vidieť\r\n                    rozdiel, ktorý ich zmena prinesie.\r\n                </p>\r\n                <h3>Ovládanie</h3>\r\n                <p>\r\n                    Tlačidlo <i>Generovať</i> vľavo vygeneruje nový list s náhodnymi hodnotami. Veľkosť toho listu určuje potom hodnota <i>Počet prvkov</i>, ktorá sa dá \r\n                    upraviť sliderom. Každý modrý pásik potom predstavuje hodnotu medzi 5 až 1000 (celé čísla). Tlačidlo <i>Zoradiť</i> potom zoradí momentálny list\r\n                    za využitia práve zvoleného algoritmu. Algoritmy možno voliť z dropdownu vedľa tlačidla <i>Generovať</i>. Otáznik naľavo od dropdownu zobrazí infokartu\r\n                    o práve zvolenom algoritme. Rýchlosť akou triedenie prebieha určuje malé pole vedľa tlačidla <i>Zoradiť</i>. Do tohto poľa je možné vpísať ľubovolné\r\n                    čislo. Toto čislo potom predstavuje zdržanie v <i>milisekundách</i>, ktoré bude medzi jednotlivími krokmi algoritmu. Základna hodnota pre toto pole\r\n                    je 5<i>ms</i>. Táto hodnota je potom použitá ak je do poľa zadaná nesprávna hodnota (text) alebo nie je zadaná žiadna hodnota. Doporučené sú hodnoty medzi\r\n                    1 až 50 <i>ms</i>. Ale ak máte celý deň podporované sú hodnoty aj nad 1000<i>ms</i>. Pre bubble sort doporučujem rýchlosť 1<i>ms</i> pre <i>Počet prvkov</i> nad \r\n                    75 prvkov.\r\n                </p>\r\n                <h3>Predpoklady pre užívateľa</h3>\r\n                <p>\r\n                    Aplikácia nie je určená pre obyčajného Ďurka alebo Janka. Predpokladá sa, že užívateľ je oboznámený so základnými princípmi programovania a vie čo znamená\r\n                    pojem <i>array</i> (v tejto aplikácii prekladám ako <i>list.</i>) <i>Pseudocode</i>, ktorým sú napísané implementácie je len mierne upravený pôvodný\r\n                    JavaScript (dúfam že názvy variabilov v ukážkach sú dosť sebavýstižné). Samotné ukážky sa len málo líšia od toho ako sú dané algoritmy implementované\r\n                    práve v tejto aplikácii.\r\n                </p>\r\n                <h3>Autor</h3>\r\n                <p>\r\n                    Aplikáciu vytvoril Martin Michálik. Vek 16 rokov. Toho času ešte žiak základnej školy.<br/>\r\n                    <a href=\"https://github.com/MatiniX/SortingVisualizer\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a>\r\n                </p>\r\n                <p style={{opacity: \"0.8\", marginTop: \"10em\"}}>\r\n                    <b>PS:</b> Ak spustíte vizualizáciu niektorého algoritmu musíte počkat až kým vizualizácia neskonči. Takže ak sa vám stane, že pustíte bubble sort\r\n                    na liste s 150+ prvkami hoci aj na základnej rýchlosti 5<i>ms</i> (ako dlho bude trvať animácia celého buble sortu môžte potom vypočitať\r\n                    vozorcomm (<i>n<sup>2</sup>*zdržanie(ms)*2</i>) kde <i>n</i> je počet prvkov). Ak sa ocitnete v takejto situácii a nechcete čakať riešením je \r\n                    stlačiť <i>F5</i> (jednoducho refreshnúť stránku). Táto infokarta sa zobrazí len pri otvorení stránky (ak ju chcete zobrziť znova musíte stránku \r\n                    zavoriť a znova otvoriť).  \r\n                </p>\r\n            </div>\r\n        </div>\r\n    )\r\n\r\n}","import React, { useState, useEffect } from \"react\"\r\nimport algorithms from \"../sortingAlgorithms/sortingAlgorithms\"\r\nimport NavBar from \"./NavBar\"\r\nimport ReactModal from \"react-modal\"\r\nimport InfoTab from \"./infoTabs/InfoTab\"\r\n\r\nfunction SortingVisualizer() {\r\n    if (sessionStorage.getItem(\"infoModalBool\") === null) {\r\n        sessionStorage.setItem(\"infoModalBool\", JSON.stringify(true));\r\n    }\r\n    const [infoModalShow, setInfoModalShow] = useState(JSON.parse(sessionStorage.getItem(\"infoModalBool\")));\r\n    \r\n\r\n    const [SORT_SPEED_MS, setSortSpeed] = useState(5);\r\n    const [ARRAY_SIZE, setArrSize] = useArray(100);\r\n    const [isSorting, setIsSorting] = useState(false);\r\n\r\n    const [arr, setArr] = useState([]);\r\n\r\n    useEffect(() => {\r\n        sessionStorage.setItem(\"infoModalBool\", infoModalShow)\r\n    },[infoModalShow]);\r\n   \r\n    function useArray(size) {\r\n        const [ARRAY_SIZE, setArrSize] = useState(size);\r\n\r\n        useEffect(() => {\r\n            function resetArrayHook() {\r\n                let arr = []\r\n                for(let i = 0; i < ARRAY_SIZE; i++){\r\n                    arr.push(randomNumFromInerval(5,1000));\r\n                }\r\n                console.log(arr);\r\n                setArr(arr);\r\n            }\r\n            resetArrayHook();\r\n        },[ARRAY_SIZE]);\r\n        return [ARRAY_SIZE, setArrSize];\r\n    }\r\n\r\n    function resetArray() {\r\n        let arr = []\r\n        for(let i = 0; i < ARRAY_SIZE; i++){\r\n            arr.push(randomNumFromInerval(5,1000));\r\n        }\r\n        console.log(arr);\r\n        setArr(arr);\r\n    }\r\n\r\n    function mergeSort() {\r\n        const arrayBars = document.getElementsByClassName(\"array-bar\");\r\n        setIsSorting(true);\r\n        algorithms.getMergeSortAnimations(arr, arrayBars, SORT_SPEED_MS, finishCallback);\r\n    }\r\n    function quickSort() {\r\n        const arrayBars = document.getElementsByClassName(\"array-bar\");\r\n        setIsSorting(true);\r\n        algorithms.getQuickSortAnimations(arr, arrayBars, SORT_SPEED_MS, finishCallback);\r\n    }\r\n    function bubbleSort() {\r\n        toggleButtons(true);\r\n        const animations = algorithms.getBubbleSortAnimations(arr);\r\n        for (let i = 0; i < animations.length; i++) {\r\n            const arrayBars = document.getElementsByClassName(\"array-bar\");\r\n            const isSwap = i % 4 === 1 || i % 4 === 2;\r\n            if (isSwap) {\r\n                setTimeout(() => {\r\n                    const [barIndex, newHeight] = animations[i];\r\n                    const barStyle = arrayBars[barIndex].style;\r\n                    barStyle.height = `${newHeight * 0.75}px`;\r\n                }, i * SORT_SPEED_MS);\r\n                \r\n            }\r\n            else {\r\n                const color = i % 4 === 0 ?  '#dd0510' : '#05b2dd';\r\n                const [barOneIdx, barTwoIdx] = animations[i];\r\n                const barOneStyle = arrayBars[barOneIdx].style;\r\n                const barTwoStyle = arrayBars[barTwoIdx].style;\r\n                setTimeout(() => {\r\n                    barOneStyle.backgroundColor = color;\r\n                    barTwoStyle.backgroundColor = color;\r\n                    if (i === animations.length - 1) {\r\n                        toggleButtons(false);\r\n                    }\r\n                }, i * SORT_SPEED_MS);\r\n            }\r\n        }\r\n    }\r\n    function insertionSort() {\r\n        toggleButtons(true);\r\n        const animations = algorithms.getInsertionSortAnimations(arr);\r\n        console.log(animations);\r\n        for (let i = 0; i < animations.length; i++) {\r\n            const arrayBars = document.getElementsByClassName(\"array-bar\");\r\n            if (i === 0) {\r\n                const barStyle = arrayBars[i].style;\r\n                setTimeout(() => {\r\n                    barStyle.backgroundColor = 'green';\r\n\r\n                }, i * SORT_SPEED_MS);\r\n            }\r\n            else if (i === animations.length - 1) {\r\n                for (let bar of arrayBars) {\r\n                    const barStyle = bar.style;\r\n                    setTimeout(() => {\r\n                        barStyle.backgroundColor = '#05b2dd';\r\n                        toggleButtons(false);\r\n                    }, i * SORT_SPEED_MS);\r\n                }\r\n            }\r\n            else {\r\n                const [barIndex, newHeight, color] = animations[i];\r\n                const barStyle = arrayBars[barIndex].style;\r\n                setTimeout(() => {\r\n                    barStyle.backgroundColor = color;\r\n                    barStyle.height = `${newHeight * 0.75}px`;\r\n                }, i * SORT_SPEED_MS);\r\n            }\r\n        }\r\n    }\r\n    function selectionSort() {\r\n        toggleButtons(true);\r\n        const animations = algorithms.getSelectionSortAnimations(arr);\r\n        console.log(animations);\r\n        for (let i = 0; i < animations.length; i++) {\r\n            const arrayBars = document.getElementsByClassName(\"array-bar\");\r\n            if (i === animations.length - 1) {\r\n                for (let bar of arrayBars) {\r\n                    const barStyle = bar.style;\r\n                    setTimeout(() => {\r\n                        barStyle.backgroundColor = '#05b2dd';\r\n                        toggleButtons(false);\r\n                    }, i * SORT_SPEED_MS);\r\n                }\r\n            }\r\n            else {\r\n                const [idx, newHeight, color] = animations[i];\r\n                const barStyle = arrayBars[idx].style;\r\n                setTimeout(() => {\r\n                    barStyle.height = `${newHeight * 0.75}px`;\r\n                    barStyle.backgroundColor = color;\r\n                }, i * SORT_SPEED_MS);\r\n            }\r\n        }\r\n    }\r\n    function shellSort() {\r\n        toggleButtons(true);\r\n        const animations = algorithms.getShellSortAnimations(arr);\r\n        console.log(animations);\r\n        for (let i = 0; i < animations.length; i++) {\r\n            const arrayBars = document.getElementsByClassName(\"array-bar\");\r\n            const [barOne, barTwo, state] = animations[i];\r\n            if (state === \"compare\") {\r\n                const barOneStyle = arrayBars[barOne].style;\r\n                const barTwoStyle = arrayBars[barTwo].style;\r\n                setTimeout(() => {\r\n                    barOneStyle.backgroundColor = barOneStyle.backgroundColor !== '#05b2dd'? '#dd0510' : '#05b2dd';\r\n                    barTwoStyle.backgroundColor = barTwoStyle.backgroundColor !== '#05b2dd'? '#dd0510' : '#05b2dd';\r\n                }, i * SORT_SPEED_MS);\r\n            }\r\n            else {\r\n                const barStyle = arrayBars[barOne].style;\r\n                setTimeout(() => {\r\n                    barStyle.backgroundColor = state;\r\n                    barStyle.height = `${barTwo * 0.75}px`;\r\n                    if (i === animations.length - 1) {\r\n                        toggleButtons(false);\r\n                    }\r\n                }, i * SORT_SPEED_MS);\r\n            }\r\n        }\r\n    }\r\n\r\n    function finishCallback() {\r\n        setIsSorting(false);\r\n    }\r\n    function toggleButtons(enabled) {\r\n        let genButton = document.getElementById(\"genButton\")\r\n        let sortButton = document.getElementById(\"sortButton\")\r\n        console.log(genButton);\r\n        console.log(sortButton);\r\n        genButton.disabled = enabled;\r\n        sortButton.disabled = enabled;\r\n    }\r\n\r\n    return(\r\n        <>\r\n            <NavBar methods={{\r\n                resetArray: resetArray,\r\n                setArrSize: setArrSize,\r\n                setSortSpeed: setSortSpeed,\r\n                setIsSorting: setIsSorting,\r\n                mergeSort: mergeSort,\r\n                quickSort: quickSort,\r\n                bubbleSort: bubbleSort,\r\n                insertionSort: insertionSort,\r\n                selectionSort: selectionSort,\r\n                shellSort: shellSort\r\n            }}\r\n             arrSize={ARRAY_SIZE} sortSpeed={SORT_SPEED_MS} isSorting={isSorting}/>\r\n            <div className=\"array-container\">\r\n            {arr.map((value, index) => \r\n                <div className=\"array-bar\" key={index} style={{height:`${value * 0.75}px`}}>\r\n                </div>\r\n            )}\r\n            </div>\r\n            <ReactModal isOpen={infoModalShow} >\r\n                <InfoTab close={() => setInfoModalShow(false)}/>\r\n            </ReactModal>\r\n        </>\r\n    )\r\n}\r\n\r\nconst randomNumFromInerval = (min, max) => Math.max(min, Math.round(max * Math.random()))\r\n\r\nexport default SortingVisualizer","import React from 'react';\nimport './App.css';\nimport SortingVisualizer from \"./components/SortingVisualizer\"\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}